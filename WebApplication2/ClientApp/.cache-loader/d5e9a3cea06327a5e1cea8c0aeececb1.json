{"remainingRequest":"C:\\Users\\liuli\\source\\repos\\github\\WalkingTec.Mvvm\\WebApplication2\\ClientApp\\node_modules\\babel-loader\\lib\\index.js??ref--4-oneOf-1-1!C:\\Users\\liuli\\source\\repos\\github\\WalkingTec.Mvvm\\WebApplication2\\ClientApp\\node_modules\\async-validator\\es\\index.js","dependencies":[{"path":"C:\\Users\\liuli\\source\\repos\\github\\WalkingTec.Mvvm\\WebApplication2\\ClientApp\\node_modules\\async-validator\\es\\index.js","mtime":499162500000},{"path":"C:\\Users\\liuli\\source\\repos\\github\\WalkingTec.Mvvm\\WebApplication2\\ClientApp\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\liuli\\source\\repos\\github\\WalkingTec.Mvvm\\WebApplication2\\ClientApp\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _extends from 'babel-runtime/helpers/extends';\nimport _typeof from 'babel-runtime/helpers/typeof';\nimport { format, complementError, asyncMap, warning, deepMerge } from './util';\nimport validators from './validator/';\nimport { messages as defaultMessages, newMessages } from './messages';\n/**\n *  Encapsulates a validation schema.\n *\n *  @param descriptor An object declaring validation rules\n *  for this schema.\n */\n\nfunction Schema(descriptor) {\n  this.rules = null;\n  this._messages = defaultMessages;\n  this.define(descriptor);\n}\n\nSchema.prototype = {\n  messages: function messages(_messages) {\n    if (_messages) {\n      this._messages = deepMerge(newMessages(), _messages);\n    }\n\n    return this._messages;\n  },\n  define: function define(rules) {\n    if (!rules) {\n      throw new Error('Cannot configure a schema with no rules');\n    }\n\n    if ((typeof rules === 'undefined' ? 'undefined' : _typeof(rules)) !== 'object' || Array.isArray(rules)) {\n      throw new Error('Rules must be an object');\n    }\n\n    this.rules = {};\n    var z = void 0;\n    var item = void 0;\n\n    for (z in rules) {\n      if (rules.hasOwnProperty(z)) {\n        item = rules[z];\n        this.rules[z] = Array.isArray(item) ? item : [item];\n      }\n    }\n  },\n  validate: function validate(source_) {\n    var _this = this;\n\n    var o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var oc = arguments[2];\n    var source = source_;\n    var options = o;\n    var callback = oc;\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    if (!this.rules || Object.keys(this.rules).length === 0) {\n      if (callback) {\n        callback();\n      }\n\n      return;\n    }\n\n    function complete(results) {\n      var i = void 0;\n      var field = void 0;\n      var errors = [];\n      var fields = {};\n\n      function add(e) {\n        if (Array.isArray(e)) {\n          errors = errors.concat.apply(errors, e);\n        } else {\n          errors.push(e);\n        }\n      }\n\n      for (i = 0; i < results.length; i++) {\n        add(results[i]);\n      }\n\n      if (!errors.length) {\n        errors = null;\n        fields = null;\n      } else {\n        for (i = 0; i < errors.length; i++) {\n          field = errors[i].field;\n          fields[field] = fields[field] || [];\n          fields[field].push(errors[i]);\n        }\n      }\n\n      callback(errors, fields);\n    }\n\n    if (options.messages) {\n      var messages = this.messages();\n\n      if (messages === defaultMessages) {\n        messages = newMessages();\n      }\n\n      deepMerge(messages, options.messages);\n      options.messages = messages;\n    } else {\n      options.messages = this.messages();\n    }\n\n    var arr = void 0;\n    var value = void 0;\n    var series = {};\n    var keys = options.keys || Object.keys(this.rules);\n    keys.forEach(function (z) {\n      arr = _this.rules[z];\n      value = source[z];\n      arr.forEach(function (r) {\n        var rule = r;\n\n        if (typeof rule.transform === 'function') {\n          if (source === source_) {\n            source = _extends({}, source);\n          }\n\n          value = source[z] = rule.transform(value);\n        }\n\n        if (typeof rule === 'function') {\n          rule = {\n            validator: rule\n          };\n        } else {\n          rule = _extends({}, rule);\n        }\n\n        rule.validator = _this.getValidationMethod(rule);\n        rule.field = z;\n        rule.fullField = rule.fullField || z;\n        rule.type = _this.getType(rule);\n\n        if (!rule.validator) {\n          return;\n        }\n\n        series[z] = series[z] || [];\n        series[z].push({\n          rule: rule,\n          value: value,\n          source: source,\n          field: z\n        });\n      });\n    });\n    var errorFields = {};\n    asyncMap(series, options, function (data, doIt) {\n      var rule = data.rule;\n      var deep = (rule.type === 'object' || rule.type === 'array') && (_typeof(rule.fields) === 'object' || _typeof(rule.defaultField) === 'object');\n      deep = deep && (rule.required || !rule.required && data.value);\n      rule.field = data.field;\n\n      function addFullfield(key, schema) {\n        return _extends({}, schema, {\n          fullField: rule.fullField + '.' + key\n        });\n      }\n\n      function cb() {\n        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var errors = e;\n\n        if (!Array.isArray(errors)) {\n          errors = [errors];\n        }\n\n        if (errors.length) {\n          warning('async-validator:', errors);\n        }\n\n        if (errors.length && rule.message) {\n          errors = [].concat(rule.message);\n        }\n\n        errors = errors.map(complementError(rule));\n\n        if (options.first && errors.length) {\n          errorFields[rule.field] = 1;\n          return doIt(errors);\n        }\n\n        if (!deep) {\n          doIt(errors);\n        } else {\n          // if rule is required but the target object\n          // does not exist fail at the rule level and don't\n          // go deeper\n          if (rule.required && !data.value) {\n            if (rule.message) {\n              errors = [].concat(rule.message).map(complementError(rule));\n            } else if (options.error) {\n              errors = [options.error(rule, format(options.messages.required, rule.field))];\n            } else {\n              errors = [];\n            }\n\n            return doIt(errors);\n          }\n\n          var fieldsSchema = {};\n\n          if (rule.defaultField) {\n            for (var k in data.value) {\n              if (data.value.hasOwnProperty(k)) {\n                fieldsSchema[k] = rule.defaultField;\n              }\n            }\n          }\n\n          fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);\n\n          for (var f in fieldsSchema) {\n            if (fieldsSchema.hasOwnProperty(f)) {\n              var fieldSchema = Array.isArray(fieldsSchema[f]) ? fieldsSchema[f] : [fieldsSchema[f]];\n              fieldsSchema[f] = fieldSchema.map(addFullfield.bind(null, f));\n            }\n          }\n\n          var schema = new Schema(fieldsSchema);\n          schema.messages(options.messages);\n\n          if (data.rule.options) {\n            data.rule.options.messages = options.messages;\n            data.rule.options.error = options.error;\n          }\n\n          schema.validate(data.value, data.rule.options || options, function (errs) {\n            doIt(errs && errs.length ? errors.concat(errs) : errs);\n          });\n        }\n      }\n\n      var res = rule.validator(rule, data.value, cb, data.source, options);\n\n      if (res && res.then) {\n        res.then(function () {\n          return cb();\n        }, function (e) {\n          return cb(e);\n        });\n      }\n    }, function (results) {\n      complete(results);\n    });\n  },\n  getType: function getType(rule) {\n    if (rule.type === undefined && rule.pattern instanceof RegExp) {\n      rule.type = 'pattern';\n    }\n\n    if (typeof rule.validator !== 'function' && rule.type && !validators.hasOwnProperty(rule.type)) {\n      throw new Error(format('Unknown rule type %s', rule.type));\n    }\n\n    return rule.type || 'string';\n  },\n  getValidationMethod: function getValidationMethod(rule) {\n    if (typeof rule.validator === 'function') {\n      return rule.validator;\n    }\n\n    var keys = Object.keys(rule);\n    var messageIndex = keys.indexOf('message');\n\n    if (messageIndex !== -1) {\n      keys.splice(messageIndex, 1);\n    }\n\n    if (keys.length === 1 && keys[0] === 'required') {\n      return validators.required;\n    }\n\n    return validators[this.getType(rule)] || false;\n  }\n};\n\nSchema.register = function register(type, validator) {\n  if (typeof validator !== 'function') {\n    throw new Error('Cannot register a validator by type, validator is not a function');\n  }\n\n  validators[type] = validator;\n};\n\nSchema.messages = defaultMessages;\nexport default Schema;",{"version":3,"sources":["C:\\Users\\liuli\\source\\repos\\github\\WalkingTec.Mvvm\\WebApplication2\\ClientApp\\node_modules\\async-validator\\es\\index.js"],"names":["_extends","_typeof","format","complementError","asyncMap","warning","deepMerge","validators","messages","defaultMessages","newMessages","Schema","descriptor","rules","_messages","define","prototype","Error","Array","isArray","z","item","hasOwnProperty","validate","source_","_this","o","arguments","length","undefined","oc","source","options","callback","Object","keys","complete","results","i","field","errors","fields","add","e","concat","apply","push","arr","value","series","forEach","r","rule","transform","validator","getValidationMethod","fullField","type","getType","errorFields","data","doIt","deep","defaultField","required","addFullfield","key","schema","cb","message","map","first","error","fieldsSchema","k","f","fieldSchema","bind","errs","res","then","pattern","RegExp","messageIndex","indexOf","splice","register"],"mappings":"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","sourcesContent":["import _extends from 'babel-runtime/helpers/extends';\nimport _typeof from 'babel-runtime/helpers/typeof';\nimport { format, complementError, asyncMap, warning, deepMerge } from './util';\nimport validators from './validator/';\nimport { messages as defaultMessages, newMessages } from './messages';\n\n/**\n *  Encapsulates a validation schema.\n *\n *  @param descriptor An object declaring validation rules\n *  for this schema.\n */\nfunction Schema(descriptor) {\n  this.rules = null;\n  this._messages = defaultMessages;\n  this.define(descriptor);\n}\n\nSchema.prototype = {\n  messages: function messages(_messages) {\n    if (_messages) {\n      this._messages = deepMerge(newMessages(), _messages);\n    }\n    return this._messages;\n  },\n  define: function define(rules) {\n    if (!rules) {\n      throw new Error('Cannot configure a schema with no rules');\n    }\n    if ((typeof rules === 'undefined' ? 'undefined' : _typeof(rules)) !== 'object' || Array.isArray(rules)) {\n      throw new Error('Rules must be an object');\n    }\n    this.rules = {};\n    var z = void 0;\n    var item = void 0;\n    for (z in rules) {\n      if (rules.hasOwnProperty(z)) {\n        item = rules[z];\n        this.rules[z] = Array.isArray(item) ? item : [item];\n      }\n    }\n  },\n  validate: function validate(source_) {\n    var _this = this;\n\n    var o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var oc = arguments[2];\n\n    var source = source_;\n    var options = o;\n    var callback = oc;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    if (!this.rules || Object.keys(this.rules).length === 0) {\n      if (callback) {\n        callback();\n      }\n      return;\n    }\n    function complete(results) {\n      var i = void 0;\n      var field = void 0;\n      var errors = [];\n      var fields = {};\n\n      function add(e) {\n        if (Array.isArray(e)) {\n          errors = errors.concat.apply(errors, e);\n        } else {\n          errors.push(e);\n        }\n      }\n\n      for (i = 0; i < results.length; i++) {\n        add(results[i]);\n      }\n      if (!errors.length) {\n        errors = null;\n        fields = null;\n      } else {\n        for (i = 0; i < errors.length; i++) {\n          field = errors[i].field;\n          fields[field] = fields[field] || [];\n          fields[field].push(errors[i]);\n        }\n      }\n      callback(errors, fields);\n    }\n\n    if (options.messages) {\n      var messages = this.messages();\n      if (messages === defaultMessages) {\n        messages = newMessages();\n      }\n      deepMerge(messages, options.messages);\n      options.messages = messages;\n    } else {\n      options.messages = this.messages();\n    }\n    var arr = void 0;\n    var value = void 0;\n    var series = {};\n    var keys = options.keys || Object.keys(this.rules);\n    keys.forEach(function (z) {\n      arr = _this.rules[z];\n      value = source[z];\n      arr.forEach(function (r) {\n        var rule = r;\n        if (typeof rule.transform === 'function') {\n          if (source === source_) {\n            source = _extends({}, source);\n          }\n          value = source[z] = rule.transform(value);\n        }\n        if (typeof rule === 'function') {\n          rule = {\n            validator: rule\n          };\n        } else {\n          rule = _extends({}, rule);\n        }\n        rule.validator = _this.getValidationMethod(rule);\n        rule.field = z;\n        rule.fullField = rule.fullField || z;\n        rule.type = _this.getType(rule);\n        if (!rule.validator) {\n          return;\n        }\n        series[z] = series[z] || [];\n        series[z].push({\n          rule: rule,\n          value: value,\n          source: source,\n          field: z\n        });\n      });\n    });\n    var errorFields = {};\n    asyncMap(series, options, function (data, doIt) {\n      var rule = data.rule;\n      var deep = (rule.type === 'object' || rule.type === 'array') && (_typeof(rule.fields) === 'object' || _typeof(rule.defaultField) === 'object');\n      deep = deep && (rule.required || !rule.required && data.value);\n      rule.field = data.field;\n      function addFullfield(key, schema) {\n        return _extends({}, schema, {\n          fullField: rule.fullField + '.' + key\n        });\n      }\n\n      function cb() {\n        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n        var errors = e;\n        if (!Array.isArray(errors)) {\n          errors = [errors];\n        }\n        if (errors.length) {\n          warning('async-validator:', errors);\n        }\n        if (errors.length && rule.message) {\n          errors = [].concat(rule.message);\n        }\n\n        errors = errors.map(complementError(rule));\n\n        if (options.first && errors.length) {\n          errorFields[rule.field] = 1;\n          return doIt(errors);\n        }\n        if (!deep) {\n          doIt(errors);\n        } else {\n          // if rule is required but the target object\n          // does not exist fail at the rule level and don't\n          // go deeper\n          if (rule.required && !data.value) {\n            if (rule.message) {\n              errors = [].concat(rule.message).map(complementError(rule));\n            } else if (options.error) {\n              errors = [options.error(rule, format(options.messages.required, rule.field))];\n            } else {\n              errors = [];\n            }\n            return doIt(errors);\n          }\n\n          var fieldsSchema = {};\n          if (rule.defaultField) {\n            for (var k in data.value) {\n              if (data.value.hasOwnProperty(k)) {\n                fieldsSchema[k] = rule.defaultField;\n              }\n            }\n          }\n          fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);\n          for (var f in fieldsSchema) {\n            if (fieldsSchema.hasOwnProperty(f)) {\n              var fieldSchema = Array.isArray(fieldsSchema[f]) ? fieldsSchema[f] : [fieldsSchema[f]];\n              fieldsSchema[f] = fieldSchema.map(addFullfield.bind(null, f));\n            }\n          }\n          var schema = new Schema(fieldsSchema);\n          schema.messages(options.messages);\n          if (data.rule.options) {\n            data.rule.options.messages = options.messages;\n            data.rule.options.error = options.error;\n          }\n          schema.validate(data.value, data.rule.options || options, function (errs) {\n            doIt(errs && errs.length ? errors.concat(errs) : errs);\n          });\n        }\n      }\n\n      var res = rule.validator(rule, data.value, cb, data.source, options);\n      if (res && res.then) {\n        res.then(function () {\n          return cb();\n        }, function (e) {\n          return cb(e);\n        });\n      }\n    }, function (results) {\n      complete(results);\n    });\n  },\n  getType: function getType(rule) {\n    if (rule.type === undefined && rule.pattern instanceof RegExp) {\n      rule.type = 'pattern';\n    }\n    if (typeof rule.validator !== 'function' && rule.type && !validators.hasOwnProperty(rule.type)) {\n      throw new Error(format('Unknown rule type %s', rule.type));\n    }\n    return rule.type || 'string';\n  },\n  getValidationMethod: function getValidationMethod(rule) {\n    if (typeof rule.validator === 'function') {\n      return rule.validator;\n    }\n    var keys = Object.keys(rule);\n    var messageIndex = keys.indexOf('message');\n    if (messageIndex !== -1) {\n      keys.splice(messageIndex, 1);\n    }\n    if (keys.length === 1 && keys[0] === 'required') {\n      return validators.required;\n    }\n    return validators[this.getType(rule)] || false;\n  }\n};\n\nSchema.register = function register(type, validator) {\n  if (typeof validator !== 'function') {\n    throw new Error('Cannot register a validator by type, validator is not a function');\n  }\n  validators[type] = validator;\n};\n\nSchema.messages = defaultMessages;\n\nexport default Schema;"]}]}