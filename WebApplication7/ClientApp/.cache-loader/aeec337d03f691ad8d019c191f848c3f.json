{"remainingRequest":"C:\\Users\\liuli\\source\\repos\\github\\WalkingTec.Mvvm\\WebApplication7\\ClientApp\\node_modules\\babel-loader\\lib\\index.js??ref--4-oneOf-1-1!C:\\Users\\liuli\\source\\repos\\github\\WalkingTec.Mvvm\\WebApplication7\\ClientApp\\node_modules\\history\\es\\createHashHistory.js","dependencies":[{"path":"C:\\Users\\liuli\\source\\repos\\github\\WalkingTec.Mvvm\\WebApplication7\\ClientApp\\node_modules\\history\\es\\createHashHistory.js","mtime":1503477301000},{"path":"C:\\Users\\liuli\\source\\repos\\github\\WalkingTec.Mvvm\\WebApplication7\\ClientApp\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\liuli\\source\\repos\\github\\WalkingTec.Mvvm\\WebApplication7\\ClientApp\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nimport warning from 'warning';\nimport invariant from 'invariant';\nimport { createLocation, locationsAreEqual } from './LocationUtils';\nimport { addLeadingSlash, stripLeadingSlash, stripTrailingSlash, hasBasename, stripBasename, createPath } from './PathUtils';\nimport createTransitionManager from './createTransitionManager';\nimport { canUseDOM, addEventListener, removeEventListener, getConfirmation, supportsGoWithoutReloadUsingHash } from './DOMUtils';\nvar HashChangeEvent = 'hashchange';\nvar HashPathCoders = {\n  hashbang: {\n    encodePath: function encodePath(path) {\n      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);\n    },\n    decodePath: function decodePath(path) {\n      return path.charAt(0) === '!' ? path.substr(1) : path;\n    }\n  },\n  noslash: {\n    encodePath: stripLeadingSlash,\n    decodePath: addLeadingSlash\n  },\n  slash: {\n    encodePath: addLeadingSlash,\n    decodePath: addLeadingSlash\n  }\n};\n\nvar getHashPath = function getHashPath() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var hashIndex = href.indexOf('#');\n  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\n};\n\nvar pushHashPath = function pushHashPath(path) {\n  return window.location.hash = path;\n};\n\nvar replaceHashPath = function replaceHashPath(path) {\n  var hashIndex = window.location.href.indexOf('#');\n  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\n};\n\nvar createHashHistory = function createHashHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  invariant(canUseDOM, 'Hash history needs a DOM');\n  var globalHistory = window.history;\n  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();\n  var _props$getUserConfirm = props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,\n      _props$hashType = props.hashType,\n      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\n      encodePath = _HashPathCoders$hashT.encodePath,\n      decodePath = _HashPathCoders$hashT.decodePath;\n\n  var getDOMLocation = function getDOMLocation() {\n    var path = decodePath(getHashPath());\n    warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n    if (basename) path = stripBasename(path, basename);\n    return createLocation(path);\n  };\n\n  var transitionManager = createTransitionManager();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var forceNextPop = false;\n  var ignorePath = null;\n\n  var handleHashChange = function handleHashChange() {\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n\n    if (path !== encodedPath) {\n      // Ensure we always have a properly-encoded hash.\n      replaceHashPath(encodedPath);\n    } else {\n      var location = getDOMLocation();\n      var prevLocation = history.location;\n      if (!forceNextPop && locationsAreEqual(prevLocation, location)) return; // A hashchange doesn't always == location change.\n\n      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.\n\n      ignorePath = null;\n      handlePop(location);\n    }\n  };\n\n  var handlePop = function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({\n            action: action,\n            location: location\n          });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  };\n\n  var revertPop = function revertPop(fromLocation) {\n    var toLocation = history.location; // TODO: We could probably make this more reliable by\n    // keeping a list of paths we've seen in sessionStorage.\n    // Instead, we just default to 0 for paths we don't know.\n\n    var toIndex = allPaths.lastIndexOf(createPath(toLocation));\n    if (toIndex === -1) toIndex = 0;\n    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\n    if (fromIndex === -1) fromIndex = 0;\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  }; // Ensure the hash is encoded properly before doing anything else.\n\n\n  var path = getHashPath();\n  var encodedPath = encodePath(path);\n  if (path !== encodedPath) replaceHashPath(encodedPath);\n  var initialLocation = getDOMLocation();\n  var allPaths = [createPath(initialLocation)]; // Public interface\n\n  var createHref = function createHref(location) {\n    return '#' + encodePath(basename + createPath(location));\n  };\n\n  var push = function push(path, state) {\n    warning(state === undefined, 'Hash history cannot push state; it is ignored');\n    var action = 'PUSH';\n    var location = createLocation(path, undefined, undefined, history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a PUSH, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        pushHashPath(encodedPath);\n        var prevIndex = allPaths.lastIndexOf(createPath(history.location));\n        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n        nextPaths.push(path);\n        allPaths = nextPaths;\n        setState({\n          action: action,\n          location: location\n        });\n      } else {\n        warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');\n        setState();\n      }\n    });\n  };\n\n  var replace = function replace(path, state) {\n    warning(state === undefined, 'Hash history cannot replace state; it is ignored');\n    var action = 'REPLACE';\n    var location = createLocation(path, undefined, undefined, history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a REPLACE, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        replaceHashPath(encodedPath);\n      }\n\n      var prevIndex = allPaths.indexOf(createPath(history.location));\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\n      setState({\n        action: action,\n        location: location\n      });\n    });\n  };\n\n  var go = function go(n) {\n    warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');\n    globalHistory.go(n);\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var listenerCount = 0;\n\n  var checkDOMListeners = function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1) {\n      addEventListener(window, HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      removeEventListener(window, HashChangeEvent, handleHashChange);\n    }\n  };\n\n  var isBlocked = false;\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  };\n\n  var listen = function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  };\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n  return history;\n};\n\nexport default createHashHistory;",{"version":3,"sources":["C:\\Users\\liuli\\source\\repos\\github\\WalkingTec.Mvvm\\WebApplication7\\ClientApp\\node_modules\\history\\es\\createHashHistory.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","warning","invariant","createLocation","locationsAreEqual","addLeadingSlash","stripLeadingSlash","stripTrailingSlash","hasBasename","stripBasename","createPath","createTransitionManager","canUseDOM","addEventListener","removeEventListener","getConfirmation","supportsGoWithoutReloadUsingHash","HashChangeEvent","HashPathCoders","hashbang","encodePath","path","charAt","decodePath","substr","noslash","slash","getHashPath","href","window","location","hashIndex","indexOf","substring","pushHashPath","hash","replaceHashPath","replace","slice","createHashHistory","props","undefined","globalHistory","history","canGoWithoutReload","_props$getUserConfirm","getUserConfirmation","_props$hashType","hashType","basename","_HashPathCoders$hashT","getDOMLocation","transitionManager","setState","nextState","notifyListeners","action","forceNextPop","ignorePath","handleHashChange","encodedPath","prevLocation","handlePop","confirmTransitionTo","ok","revertPop","fromLocation","toLocation","toIndex","allPaths","lastIndexOf","fromIndex","delta","go","initialLocation","createHref","push","state","hashChanged","prevIndex","nextPaths","n","goBack","goForward","listenerCount","checkDOMListeners","isBlocked","block","prompt","unblock","setPrompt","listen","listener","unlisten","appendListener"],"mappings":"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","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport warning from 'warning';\nimport invariant from 'invariant';\nimport { createLocation, locationsAreEqual } from './LocationUtils';\nimport { addLeadingSlash, stripLeadingSlash, stripTrailingSlash, hasBasename, stripBasename, createPath } from './PathUtils';\nimport createTransitionManager from './createTransitionManager';\nimport { canUseDOM, addEventListener, removeEventListener, getConfirmation, supportsGoWithoutReloadUsingHash } from './DOMUtils';\n\nvar HashChangeEvent = 'hashchange';\n\nvar HashPathCoders = {\n  hashbang: {\n    encodePath: function encodePath(path) {\n      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);\n    },\n    decodePath: function decodePath(path) {\n      return path.charAt(0) === '!' ? path.substr(1) : path;\n    }\n  },\n  noslash: {\n    encodePath: stripLeadingSlash,\n    decodePath: addLeadingSlash\n  },\n  slash: {\n    encodePath: addLeadingSlash,\n    decodePath: addLeadingSlash\n  }\n};\n\nvar getHashPath = function getHashPath() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var hashIndex = href.indexOf('#');\n  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\n};\n\nvar pushHashPath = function pushHashPath(path) {\n  return window.location.hash = path;\n};\n\nvar replaceHashPath = function replaceHashPath(path) {\n  var hashIndex = window.location.href.indexOf('#');\n\n  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\n};\n\nvar createHashHistory = function createHashHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  invariant(canUseDOM, 'Hash history needs a DOM');\n\n  var globalHistory = window.history;\n  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();\n\n  var _props$getUserConfirm = props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,\n      _props$hashType = props.hashType,\n      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;\n\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\n      encodePath = _HashPathCoders$hashT.encodePath,\n      decodePath = _HashPathCoders$hashT.decodePath;\n\n\n  var getDOMLocation = function getDOMLocation() {\n    var path = decodePath(getHashPath());\n\n    warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n\n    if (basename) path = stripBasename(path, basename);\n\n    return createLocation(path);\n  };\n\n  var transitionManager = createTransitionManager();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var forceNextPop = false;\n  var ignorePath = null;\n\n  var handleHashChange = function handleHashChange() {\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n\n    if (path !== encodedPath) {\n      // Ensure we always have a properly-encoded hash.\n      replaceHashPath(encodedPath);\n    } else {\n      var location = getDOMLocation();\n      var prevLocation = history.location;\n\n      if (!forceNextPop && locationsAreEqual(prevLocation, location)) return; // A hashchange doesn't always == location change.\n\n      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.\n\n      ignorePath = null;\n\n      handlePop(location);\n    }\n  };\n\n  var handlePop = function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({ action: action, location: location });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  };\n\n  var revertPop = function revertPop(fromLocation) {\n    var toLocation = history.location;\n\n    // TODO: We could probably make this more reliable by\n    // keeping a list of paths we've seen in sessionStorage.\n    // Instead, we just default to 0 for paths we don't know.\n\n    var toIndex = allPaths.lastIndexOf(createPath(toLocation));\n\n    if (toIndex === -1) toIndex = 0;\n\n    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\n\n    if (fromIndex === -1) fromIndex = 0;\n\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  };\n\n  // Ensure the hash is encoded properly before doing anything else.\n  var path = getHashPath();\n  var encodedPath = encodePath(path);\n\n  if (path !== encodedPath) replaceHashPath(encodedPath);\n\n  var initialLocation = getDOMLocation();\n  var allPaths = [createPath(initialLocation)];\n\n  // Public interface\n\n  var createHref = function createHref(location) {\n    return '#' + encodePath(basename + createPath(location));\n  };\n\n  var push = function push(path, state) {\n    warning(state === undefined, 'Hash history cannot push state; it is ignored');\n\n    var action = 'PUSH';\n    var location = createLocation(path, undefined, undefined, history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a PUSH, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        pushHashPath(encodedPath);\n\n        var prevIndex = allPaths.lastIndexOf(createPath(history.location));\n        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n\n        nextPaths.push(path);\n        allPaths = nextPaths;\n\n        setState({ action: action, location: location });\n      } else {\n        warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');\n\n        setState();\n      }\n    });\n  };\n\n  var replace = function replace(path, state) {\n    warning(state === undefined, 'Hash history cannot replace state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = createLocation(path, undefined, undefined, history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a REPLACE, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        replaceHashPath(encodedPath);\n      }\n\n      var prevIndex = allPaths.indexOf(createPath(history.location));\n\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\n\n      setState({ action: action, location: location });\n    });\n  };\n\n  var go = function go(n) {\n    warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');\n\n    globalHistory.go(n);\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var listenerCount = 0;\n\n  var checkDOMListeners = function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1) {\n      addEventListener(window, HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      removeEventListener(window, HashChangeEvent, handleHashChange);\n    }\n  };\n\n  var isBlocked = false;\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  };\n\n  var listen = function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  };\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\nexport default createHashHistory;"]}]}