{"remainingRequest":"C:\\Users\\liuli\\source\\repos\\github\\WalkingTec.Mvvm\\WebApplication7\\ClientApp\\node_modules\\babel-loader\\lib\\index.js??ref--4-oneOf-1-1!C:\\Users\\liuli\\source\\repos\\github\\WalkingTec.Mvvm\\WebApplication7\\ClientApp\\node_modules\\async-validator\\es\\rule\\pattern.js","dependencies":[{"path":"C:\\Users\\liuli\\source\\repos\\github\\WalkingTec.Mvvm\\WebApplication7\\ClientApp\\node_modules\\async-validator\\es\\rule\\pattern.js","mtime":499162500000},{"path":"C:\\Users\\liuli\\source\\repos\\github\\WalkingTec.Mvvm\\WebApplication7\\ClientApp\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\liuli\\source\\repos\\github\\WalkingTec.Mvvm\\WebApplication7\\ClientApp\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import * as util from '../util';\n/**\n *  Rule for validating a regular expression pattern.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param source The source object being validated.\n *  @param errors An array of errors that this rule may add\n *  validation errors to.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction pattern(rule, value, source, errors, options) {\n  if (rule.pattern) {\n    if (rule.pattern instanceof RegExp) {\n      // if a RegExp instance is passed, reset `lastIndex` in case its `global`\n      // flag is accidentally set to `true`, which in a validation scenario\n      // is not necessary and the result might be misleading\n      rule.pattern.lastIndex = 0;\n\n      if (!rule.pattern.test(value)) {\n        errors.push(util.format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\n      }\n    } else if (typeof rule.pattern === 'string') {\n      var _pattern = new RegExp(rule.pattern);\n\n      if (!_pattern.test(value)) {\n        errors.push(util.format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\n      }\n    }\n  }\n}\n\nexport default pattern;",{"version":3,"sources":["C:\\Users\\liuli\\source\\repos\\github\\WalkingTec.Mvvm\\WebApplication7\\ClientApp\\node_modules\\async-validator\\es\\rule\\pattern.js"],"names":["util","pattern","rule","value","source","errors","options","RegExp","lastIndex","test","push","format","messages","mismatch","fullField","_pattern"],"mappings":"AAAA,OAAO,KAAKA,IAAZ,MAAsB,SAAtB;AAEA;;;;;;;;;;;;AAWA,SAASC,OAAT,CAAiBC,IAAjB,EAAuBC,KAAvB,EAA8BC,MAA9B,EAAsCC,MAAtC,EAA8CC,OAA9C,EAAuD;AACrD,MAAIJ,IAAI,CAACD,OAAT,EAAkB;AAChB,QAAIC,IAAI,CAACD,OAAL,YAAwBM,MAA5B,EAAoC;AAClC;AACA;AACA;AACAL,MAAAA,IAAI,CAACD,OAAL,CAAaO,SAAb,GAAyB,CAAzB;;AACA,UAAI,CAACN,IAAI,CAACD,OAAL,CAAaQ,IAAb,CAAkBN,KAAlB,CAAL,EAA+B;AAC7BE,QAAAA,MAAM,CAACK,IAAP,CAAYV,IAAI,CAACW,MAAL,CAAYL,OAAO,CAACM,QAAR,CAAiBX,OAAjB,CAAyBY,QAArC,EAA+CX,IAAI,CAACY,SAApD,EAA+DX,KAA/D,EAAsED,IAAI,CAACD,OAA3E,CAAZ;AACD;AACF,KARD,MAQO,IAAI,OAAOC,IAAI,CAACD,OAAZ,KAAwB,QAA5B,EAAsC;AAC3C,UAAIc,QAAQ,GAAG,IAAIR,MAAJ,CAAWL,IAAI,CAACD,OAAhB,CAAf;;AACA,UAAI,CAACc,QAAQ,CAACN,IAAT,CAAcN,KAAd,CAAL,EAA2B;AACzBE,QAAAA,MAAM,CAACK,IAAP,CAAYV,IAAI,CAACW,MAAL,CAAYL,OAAO,CAACM,QAAR,CAAiBX,OAAjB,CAAyBY,QAArC,EAA+CX,IAAI,CAACY,SAApD,EAA+DX,KAA/D,EAAsED,IAAI,CAACD,OAA3E,CAAZ;AACD;AACF;AACF;AACF;;AAED,eAAeA,OAAf","sourcesContent":["import * as util from '../util';\n\n/**\n *  Rule for validating a regular expression pattern.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param source The source object being validated.\n *  @param errors An array of errors that this rule may add\n *  validation errors to.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\nfunction pattern(rule, value, source, errors, options) {\n  if (rule.pattern) {\n    if (rule.pattern instanceof RegExp) {\n      // if a RegExp instance is passed, reset `lastIndex` in case its `global`\n      // flag is accidentally set to `true`, which in a validation scenario\n      // is not necessary and the result might be misleading\n      rule.pattern.lastIndex = 0;\n      if (!rule.pattern.test(value)) {\n        errors.push(util.format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\n      }\n    } else if (typeof rule.pattern === 'string') {\n      var _pattern = new RegExp(rule.pattern);\n      if (!_pattern.test(value)) {\n        errors.push(util.format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\n      }\n    }\n  }\n}\n\nexport default pattern;"]}]}